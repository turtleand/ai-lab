## Module Topic Structure Ideas
- **Explicit subtopic rows** — Simple: replace the single notes line with a short list of subtopics (e.g., "tools", "prep posts", "key secrets") shown as separate pills under each module title. Elaborated: render each module with its title/status on one line and, beneath it, a horizontal list of labeled pills or chips for each subtopic so every item is scannable at a glance; use muted pills for placeholders and accent pills for available content, keeping the overall card compact.
- **Indented bullet stack** — Simple: under each module, list subtopics as individual bullets instead of a paragraph note. Elaborated: keep the module header clean, then add an indented bullet stack that enumerates each subtopic (tools, pre-posts, key secrets, etc.) with short descriptors; this preserves the vertical list layout while making subtopics clearly separated, and allows "Coming soon" bullets for empty slots.
- **Grid of sub-cards** — Simple: turn the module detail area into a mini grid of sub-cards for each subtopic. Elaborated: when a module expands, show a 2–3 column grid of small cards, each dedicated to a subtopic with its own title, status badge, and optional link; this gives each item its own visual container so nothing blends into a single block of text, and works well for modules with many subtopics.

## Subtopic-Driven Architecture Options
- **Content-first subtopics** — Simple: derive subtopics directly from topic content entries; if no entry exists, show the pill in a muted/disabled state. Elaborated: enforce a schema where every `topics` entry includes `module` + `subtopic` keys; group and render the module view from the content collection itself, marking a subtopic active only when at least one entry exists for that `module/subtopic` pair, otherwise showing a greyed pill for the planned slot.
- **Config manifest + content check** — Simple: keep a single `subtopics.json` manifest per module and light up items when matching content exists. Elaborated: define a manifest listing all expected subtopics (order, title, summary) for each module; at runtime, hydrate it with content presence (e.g., via a map of existing `module/subtopic` IDs) to toggle states—muted when empty, active with a link when content is present—so structure is stable while content drives availability.
- **Frontmatter registry** — Simple: store subtopic definitions in module frontmatter and compute active/disabled states from content lookups. Elaborated: move subtopic lists into the module data (e.g., `modules.yaml` or module frontmatter) with ids/titles; during build, build a lookup of content files by `subtopicId`, then render each module’s list using the registry for labels/order and the lookup for state, ensuring consistent naming while still letting content presence flip pills from greyed to active.
